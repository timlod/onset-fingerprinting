#+TITLE: Minig multi-channel hits
#+AUTHOR: Tim Loderhose
#+EMAIL: tim@loderhose.com
#+DATE: Monday, 15 July 2024
#+STARTUP: showall
#+PROPERTY: header-args :exports both :session mh :kernel lm :cache no
:PROPERTIES:
OPTIONS: ^:nil
#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [logo, color, author]
#+LATEX_HEADER: \insertauthor
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage[left=0.75in,top=0.6in,right=0.75in,bottom=0.6in]{geometry}
:END:

* Imports and Environment Variables
:PROPERTIES:
:visibility: folded
:END:

#+name: imports
#+begin_src python
import json
from importlib import reload
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import sounddevice as sd
import soundfile as sf
import torch
import torch.nn as nn
from onset_fingerprinting import (
    calibration,
    data,
    detection,
    model,
    multilateration,
    plots,
)
from torch import optim
from torch.nn import functional as F
#+end_src

#+name: env
#+begin_src python
__file__ = "/home/tim/projects/onset-fingerprinting/onset_fingerprinting/detection.py"
data_dir = Path("../data")
#+end_src

* Introduction
I want to train more advanced models for onset location regression. Some
preliminary work in [[file:modelling_lags.org][Modelling Lags]] suggests that some NN architectures might be
able to learn the lag between multiple microphones corresponding to drum hit
onsets. However, NNs trained on simulated data fall apart when modelling real
drum hits. I believe the problem might still be solved, but a larger dataset
containing multi-channel onsets in real data is needed.

The plan:
- Load several recording sessions' Snare Top and Overhead channels
- Detect onsets and find groups
- Use thresholds on CC or perhaps visual filtering to get clean-enough
  datasets of correct lags


* Storage format
I believe the most straightforward way to store this data would be:
1. <dataset_name>.wav file containing audio channels
2. <dataset_name>.npy file containing lags for each channel

* Work
#+begin_src python
# 1. Load
def load_single(file: Path, channels: list[int] = [0, 1, 2], dtype=np.float32):
    wav, sr = sf.read(file, dtype=dtype)
    return wav[:, channels], sr


def load_multi(
    folder: Path, files: list[str], suffix: str = ".wav", dtype=np.float32
):
    wavs = []
    for file in files:
        wav, sr = sf.read(folder / (file + suffix), dtype=dtype)
        wavs.append(wav)
    if wav.ndim == 1:
        return np.stack(wavs, axis=1), sr
    else:
        return np.concatenate(wavs, axis=1), sr
#+end_src

#+begin_src python
data, sr = load_multi(
    data_dir / "calibration" / "2023-03-13",
    ["calib_ohl", "calib_ohr", "calib_snaretop"],
)
#+end_src

#+begin_src python
def detect(audio, close_channel=2):
    cf, of, rel = detection.detect_onsets_amplitude(
        audio,
        128,
        hipass_freq=2000,
        fast_ar=(0.4, 100),
        slow_ar=(8000, 8000),
        on_threshold=[0.3, 0.3, 0.151],
        off_threshold=0.3,
        cooldown=9000,
        sr=sr,
        backtrack=False,
        backtrack_buffer_size=256,
        backtrack_smooth_size=1,
    )
    oc = detection.find_onset_groups(of, cf, 400, close_channel=close_channel)
    occ = detection.fix_onsets(audio, oc, onset_tolerance=50, take_abs=True)
    plots.plot_onsets(audio, oc)
#+end_src

#+begin_src python
audio = data
roi = 10*sr
cf, of, rel = detect_onsets_amplitude(
    audio[:roi],
    128,
    hipass_freq=00,
    fast_ar=(1, 10000),
    slow_ar=(10000, 10000),
    on_threshold=0.2,
    off_threshold=0.2,
    cooldown=9000,
    sr=sr,
    backtrack=False,
    backtrack_buffer_size=256,
    backtrack_smooth_size=1,
)
oc = detection.find_onset_groups(of, cf, 400, close_channel=2)
occ = detection.fix_onsets(
    audio, oc, onset_tolerance=150, take_abs=True
)
print(len(occ))
plots.plot_onsets(audio[:roi], oc)
#+end_src

#+RESULTS:
:RESULTS:
: 5
: <Axes: >
[[./.ob-jupyter/2e606407ae71e4eb727420b9b013a23696fe69fc.png]]
:END:



#+begin_src python
from scipy.ndimage import median_filter
from scipy.signal import find_peaks

og = oc[3].copy()
plots.plot_group(
    audio,
    og,
    title="Detected onsets",
    channel_labels=["OH L", "OH R", "Close mic"],
)
filter_size: int = 7
d: int = 1
take_abs: bool = True
normalization_cutoff: int = 10
onset_tolerance: int = 150
lookaround = normalization_cutoff + onset_tolerance
idx = np.argsort(og)
a = og[idx[0]]
b = og[idx[2]]
sectiona = audio[a - lookaround : b + lookaround]
section = np.diff(median_filter(sectiona, filter_size, axes=0), d, axis=0)
section[section >= 0] = 0
section = np.abs(section)
section_og = og - (a - lookaround)
for i in idx[1:]:
    onsets = [section_og[idx[0]], section_og[i]]
    x = section[:, idx[0]]
    y = section[:, i]
    n = len(x)
    cc = np.correlate(x, y, "full")
    # Normalize such that each cc value with contributions
    # of more than cutoff
    # amount of elements has an equal chance to be the
    # top lag
    normalizer = np.arange(len(x)) + 1
    normalizer[:normalization_cutoff] = normalization_cutoff
    cc[:n] /= normalizer
    cc[n:] /= normalizer[n - 2 :: -1]
    current_lag = onsets[1] - onsets[0]
    lag_center = n - current_lag
    cc = cc[lag_center - onset_tolerance : lag_center + onset_tolerance]
    lags = np.arange(-n, n)
    lags = lags[lag_center - onset_tolerance : lag_center + onset_tolerance]
    max_adjust = current_lag + onset_tolerance
    plots.plot_cc(cc, n, lag_center, onset_tolerance, 3)
    new_lag = -(np.argmax(cc) - max_adjust)
    print(current_lag, new_lag)
    if new_lag is not None:
        ca, cb = detection.adjust_onset(onsets, x, y, new_lag)
        og[idx[0]] += ca
        og[i] += cb
        section_og[idx[0]] += ca
        section_og[i] += cb
        print(
            f"Moving onsets ({ca}, {cb} steps) from  {onsets} to"
            f" {section_og[idx[0]]}, {section_og[i]}!"
        )
        plots.plot_group(
            audio,
            og,
            channel_labels=["OH L", "OH R", "Close mic"],
            title="Corrected onsets",
        )
#+end_src

#+RESULTS:
:RESULTS:
: 91 238
: Moving onsets (-147, 0 steps) from  [160, 251] to 13, 251!
: 251 387
: Moving onsets (0, 136 steps) from  [13, 264] to 13, 400!
[[./.ob-jupyter/ee40b654d2002d023d0ca258b299cd5c9fc70bea.png]]
[[./.ob-jupyter/815afa82df43e93ac493b039e6f145b3fe2b0e43.png]]
[[./.ob-jupyter/9abebf20ba07e8d5e137090a804c5296f6f7abbe.png]]
[[./.ob-jupyter/c070a975a977ef8095162ef00ac352d4fb377b31.png]]
[[./.ob-jupyter/fa45903476821f9db9b07b3a5d27f131cb8071be.png]]
:END:
